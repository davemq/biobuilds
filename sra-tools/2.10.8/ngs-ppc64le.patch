--- ngs-2.10.8/ngs-bam/Makefile.install	2020-06-29 12:03:44.000000000 -0400
+++ ngs-2.10.8-p9/ngs-bam/Makefile.install	2020-07-09 11:29:15.898563000 -0400
@@ -73,6 +73,7 @@ ifeq (linux, $(OS))
         LINUX_ROOT = true
     endif
 endif
+LINUX_ROOT = false
 
 install: copylibs copyincludes copyexamples
 ifeq (true, $(LINUX_ROOT))
--- ngs-2.10.8/ngs-bam/setup/install.perl	2020-06-29 12:03:44.000000000 -0400
+++ ngs-2.10.8-p9/ngs-bam/setup/install.perl	2020-07-09 11:29:53.855749626 -0400
@@ -1315,7 +1315,7 @@ sub prepare {
     }
 }
 
-sub linux_root { $^O eq 'linux' && `id -u` == 0 }
+sub linux_root { return 0; }
 
 sub fatal_config {
     if ($OPT{debug}) {
--- ngs-2.10.8/ngs-java/Makefile.java	2020-06-29 12:03:44.000000000 -0400
+++ ngs-2.10.8-p9/ngs-java/Makefile.java	2020-07-09 11:30:42.908744879 -0400
@@ -69,6 +69,7 @@ ifeq (linux, $(OS))
         DOC_TARGET = $(ROOT)/usr/local/share/doc/ngs/
     endif
 endif
+LINUX_ROOT = false
 
 install: $(TARGETS) $(INST_JARDIR) $(INST_JARDIR)/ngs-java.jar.$(VERSION) copydocs copyexamples
 ifeq (true, $(LINUX_ROOT))
--- ngs-2.10.8/ngs-java/setup/install.perl	2020-06-29 12:03:44.000000000 -0400
+++ ngs-2.10.8-p9/ngs-java/setup/install.perl	2020-07-09 11:34:36.731848436 -0400
@@ -1312,7 +1312,7 @@ sub prepare {
     }
 }
 
-sub linux_root { $^O eq 'linux' && `id -u` == 0 }
+sub linux_root { return 0; }
 
 sub fatal_config {
     if ($OPT{debug}) {
--- ngs-2.10.8/ngs-python/setup/install.perl	2020-06-29 12:03:44.000000000 -0400
+++ ngs-2.10.8-p9/ngs-python/setup/install.perl	2020-07-09 11:38:31.274916776 -0400
@@ -1313,6 +1313,7 @@ sub prepare {
 }
 
 sub linux_root { $^O eq 'linux' && `id -u` == 0 }
+sub linux_root { return 0; }
 
 sub fatal_config {
     if ($OPT{debug}) {
--- ngs-2.10.8/ngs-sdk/Makefile.install	2020-06-29 12:03:44.000000000 -0400
+++ ngs-2.10.8-p9/ngs-sdk/Makefile.install	2020-07-09 11:40:47.025496000 -0400
@@ -72,6 +72,7 @@ ifeq (linux, $(OS))
         LINUX_ROOT = true
     endif
 endif
+LINUX_ROOT = false
 
 install: copylibs copyincludes copyexamples
 ifeq (true, $(LINUX_ROOT))
--- ngs-2.10.8/ngs-sdk/ngs/unix/ppc64le/atomic32.h	1969-12-31 19:00:00.000000000 -0500
+++ ngs-2.10.8-p9/ngs-sdk/ngs/unix/ppc64le/atomic32.h	2020-07-09 11:41:57.911930000 -0400
@@ -0,0 +1,209 @@
+/*===========================================================================
+*
+*                            PUBLIC DOMAIN NOTICE
+*               National Center for Biotechnology Information
+*
+*  This software/database is a "United States Government Work" under the
+*  terms of the United States Copyright Act.  It was written as part of
+*  the author's official duties as a United States Government employee and
+*  thus cannot be copyrighted.  This software/database is freely available
+*  to the public for use. The National Library of Medicine and the U.S.
+*  Government have not placed any restriction on its use or reproduction.
+*
+*  Although all reasonable efforts have been taken to ensure the accuracy
+*  and reliability of the software and data, the NLM and the U.S.
+*  Government do not and cannot warrant the performance or results that
+*  may be obtained by using this software or data. The NLM and the U.S.
+*  Government disclaim all warranties, express or implied, including
+*  warranties of performance, merchantability or fitness for any particular
+*  purpose.
+*
+*  Please cite the author in any work or product based on this material.
+*
+* ===========================================================================
+*
+*/
+
+/*===========================================================================
+ * Modified from x86_64 version using gcc builtins, done by Ruzhu Chen from 
+ * previous version with Cheng Lee * (cheng.lee@lab7.io). 
+ * TODO: reimplement using actual POWER8 and POWER9 assembly.
+ *=========================================================================== */
+
+#ifndef _h_atomic32_
+#define _h_atomic32_
+
+#ifndef __GNUC__
+#error ppc64le/atomic32.h currently requires gcc
+#endif
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*
+ * Make sure gcc doesn't try to be clever and move things around
+ * on us. We need to use _exactly_ the address the user gave us,
+ * not some alias that contains the same information.
+ */
+typedef struct atomic32_t atomic32_t;
+struct atomic32_t
+{
+    volatile int counter;
+};
+
+/* int atomic32_read ( const atomic32_t *v ); */
+#define atomic32_read( v ) \
+    ( ( v ) -> counter )
+
+/* void atomic32_set ( atomic32_t *v, int i ); */
+#define atomic32_set( v, i ) \
+    ( ( void ) ( ( ( v ) -> counter ) = ( i ) ) )
+
+/* add to v -> counter and return the prior value */
+static __inline__ int atomic32_read_and_add ( atomic32_t *v, int i )
+{
+    return __sync_fetch_and_add(&(v->counter), i);
+}
+
+/* if no read is needed, define the least expensive atomic add */
+#define atomic32_add( v, i ) \
+    atomic32_read_and_add ( v, i )
+
+/* add to v -> counter and return the result */
+static __inline__ int atomic32_add_and_read ( atomic32_t *v, int i )
+{
+    return __sync_add_and_fetch(&(v->counter), i);
+}
+
+/* just don't try to find out what the result was */
+static __inline__ void atomic32_inc ( atomic32_t *v )
+{
+    __sync_fetch_and_add(&(v->counter), 1);
+}
+
+static __inline__ void atomic32_dec ( atomic32_t *v )
+{
+    __sync_fetch_and_sub(&(v->counter), 1);
+}
+
+/* decrement by one and test result for 0 */
+static __inline__ int atomic32_dec_and_test ( atomic32_t *v )
+{
+    // TODO: test for correctness
+    return (__sync_sub_and_fetch(&(v->counter), 1) == 0);
+}
+
+/* when atomic32_dec_and_test uses predecrement, you want
+   postincrement to this function. so it isn't very useful */
+static __inline__ int atomic32_inc_and_test ( atomic32_t *v )
+{
+    // TODO: test for correctness
+    return (__sync_add_and_fetch(&(v->counter), 1) == 0);
+}
+
+/* HERE's useful */
+#define atomic32_test_and_inc( v ) \
+    ( atomic32_read_and_add ( v, 1 ) == 0 )
+
+static __inline__ int atomic32_test_and_set ( atomic32_t *v, int s, int t )
+{
+    return __sync_val_compare_and_swap(&(v->counter), t, s);
+}
+
+/* conditional modifications */
+static __inline__
+int atomic32_read_and_add_lt ( atomic32_t *v, int i, int t )
+{
+    // TODO: test for correctness and atomicity
+    return (v->counter < t) ?
+        __sync_fetch_and_add(&(v->counter), i) :
+        v->counter;
+}
+
+#define atomic32_add_if_lt( v, i, t ) \
+    ( atomic32_read_and_add_lt ( v, i, t ) < ( t ) )
+
+static __inline__
+int atomic32_read_and_add_le ( atomic32_t *v, int i, int t )
+{
+    // TODO: test for correctness and atomicity
+    return (v->counter <= t) ?
+        __sync_fetch_and_add(&(v->counter), i) :
+        v->counter;
+}
+
+#define atomic32_add_if_le( v, i, t ) \
+    ( atomic32_read_and_add_le ( v, i, t ) <= ( t ) )
+
+static __inline__
+int atomic32_read_and_add_eq ( atomic32_t *v, int i, int t )
+{
+    // TODO: test for correctness and atomicity
+    return (v->counter == t) ?
+        __sync_fetch_and_add(&(v->counter), i) :
+        v->counter;
+}
+
+#define atomic32_add_if_eq( v, i, t ) \
+    ( atomic32_read_and_add_eq ( v, i, t ) == ( t ) )
+
+static __inline__
+int atomic32_read_and_add_ne ( atomic32_t *v, int i, int t )
+{
+    // TODO: test for correctness and atomicity
+    return (v->counter != t) ?
+        __sync_fetch_and_add(&(v->counter), i) :
+        v->counter;
+}
+
+#define atomic32_add_if_ne( v, i, t ) \
+    ( atomic32_read_and_add_ne ( v, i, t ) != ( t ) )
+
+static __inline__
+int atomic32_read_and_add_ge ( atomic32_t *v, int i, int t )
+{
+    // TODO: test for correctness and atomicity
+    return (v->counter >= t) ?
+        __sync_fetch_and_add(&(v->counter), i) :
+        v->counter;
+}
+
+#define atomic32_add_if_ge( v, i, t ) \
+    ( atomic32_read_and_add_ge ( v, i, t ) >= ( t ) )
+
+static __inline__
+int atomic32_read_and_add_gt ( atomic32_t *v, int i, int t )
+{
+    // TODO: test for correctness and atomicity
+    return (v->counter > t) ?
+        __sync_fetch_and_add(&(v->counter), i) :
+        v->counter;
+}
+
+#define atomic32_add_if_gt( v, i, t ) \
+    ( atomic32_read_and_add_gt ( v, i, t ) > ( t ) )
+
+static __inline__
+int atomic32_read_and_add_odd ( atomic32_t *v, int i )
+{
+    // TODO: test for correctness and atomicity
+    return (v->counter % 2 == 1) ?
+         __sync_fetch_and_add(&(v->counter), i) :
+        v->counter;
+}
+
+static __inline__
+int atomic32_read_and_add_even ( atomic32_t *v, int i )
+{
+    // TODO: test for correctness and atomicity
+    return (v->counter % 2 == 0) ?
+         __sync_fetch_and_add(&(v->counter), i) :
+        v->counter;
+}
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _h_atomic32_ */
--- ngs-2.10.8/ngs-sdk/setup/install.perl	2020-06-29 12:03:44.000000000 -0400
+++ ngs-2.10.8-p9/ngs-sdk/setup/install.perl	2020-07-09 11:42:52.609968559 -0400
@@ -1312,7 +1312,7 @@ sub prepare {
     }
 }
 
-sub linux_root { $^O eq 'linux' && `id -u` == 0 }
+sub linux_root { return 0; }
 
 sub fatal_config {
     if ($OPT{debug}) {
--- ngs-2.10.8/ngs-sdk/setup/konfigure.perl	2020-06-29 12:03:44.000000000 -0400
+++ ngs-2.10.8-p9/ngs-sdk/setup/konfigure.perl	2020-07-09 11:45:36.326952908 -0400
@@ -223,7 +223,7 @@ if ($OS eq 'linux') {
 
 print "checking machine architecture... " unless ($AUTORUN);
 println $MARCH unless ($AUTORUN);
-unless ($MARCH =~ /x86_64/i || $MARCH =~ /i?86/i) {
+unless ($MARCH =~ /x86_64/i || $MARCH =~ /i?86/i || $MARCH =~ /ppc64le/i) {
     println "configure: error: unsupported architecture '$OSTYPE'";
     exit 1;
 }
@@ -310,6 +310,8 @@ my $BITS;
 
 if ($MARCH =~ /x86_64/i) {
     $BITS = 64;
+} elsif ($MARCH =~ /ppc64le/i) {
+    $BITS = 64;
 } elsif ($MARCH eq 'fat86') {
     $BITS = '32_64';
 } elsif ($MARCH =~ /i?86/i) {
@@ -331,7 +333,7 @@ if ($OSTYPE =~ /linux/i) {
     $SHLX = 'so';
     $EXEX = '';
     $OSINC = 'unix';
-    $TOOLS = 'gcc' unless ($TOOLS);
+    $TOOLS = $ENV{CC};
     $PYTHON = 'python';
 } elsif ($OSTYPE =~ /darwin/i) {
     $LPFX = 'lib';
@@ -341,12 +343,25 @@ if ($OSTYPE =~ /linux/i) {
     $SHLX = 'dylib';
     $EXEX = '';
     $OSINC = 'unix';
-    $TOOLS = 'clang' unless ($TOOLS);
+    $TOOLS = $ENV{CC};
     $PYTHON = 'python';
 } elsif ($OSTYPE eq 'win') {
     $TOOLS = 'vc++';
 } else {
-    die "unrecognized OS '$OSTYPE'";
+    $CPP  = $ENV{CXX};
+    $CC   = "$TOOLS -c";
+    $CP   = "$CPP -c";
+    $AR   = 'ar rc';
+    $ARX  = 'ar x';
+    $ARLS = 'ar t';
+    $LD   = $TOOLS;
+    $LP   = $CPP;
+
+    $DBG = '-g -DDEBUG';
+    $OPT = '-O3';
+    $PIC = '-fPIC';
+    $INC = '-I';
+    $MD  = '-MD';
 }
 
 println "$OSTYPE ($OS) is supported" unless ($AUTORUN);
