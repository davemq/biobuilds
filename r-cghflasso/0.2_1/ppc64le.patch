--- src/L2L1VitExact.c	2009-06-04 20:38:11.000000000 -0400
+++ src/L2L1VitExact.c	2020-06-29 11:24:12.441396423 -0400
@@ -86,7 +86,8 @@ void AddQuadPcwsQuad(double * inp_segs,
   double a = 2.0*qd_scale;
   double b = -2.0 * qd_root * qd_scale;
 
-  for(int i = 0; i < n_inp_segs; i++, inp_segs += FL_SEGSZ){
+  int i = 0;
+  for(i = 0; i < n_inp_segs; i++, inp_segs += FL_SEGSZ){
     double d1 = a * inp_segs[FLV_X] + b;
 	inp_segs[FLV_DY] += d1;
   }
@@ -125,7 +126,8 @@ int L2L1VitArgmax(double * inp_segs, int
 	    left_added = j;
 	    // The derivative of lambda2 is never acheived
 		//copy the left knot entirely
-		for(int k = 0; k < FL_SEGSZ; k++) rs[k] = is[k];
+		int k = 0;
+		for(k = 0; k < FL_SEGSZ; k++) rs[k] = is[k];
 		//increment the pointers
 		rs += FL_SEGSZ;
 		n_rs++;
@@ -176,7 +178,8 @@ int L2L1VitArgmax(double * inp_segs, int
 
 		if(left_added != j){
 			//copy the left knot entirely
-			for(int k = 0; k < FL_SEGSZ; k++) rs[k] = is[k];
+			int k = 0;
+			for( k = 0; k < FL_SEGSZ; k++) rs[k] = is[k];
 			//increment the pointers
 			rs += FL_SEGSZ;
 			n_rs++;
@@ -199,8 +202,8 @@ int L2L1VitArgmax(double * inp_segs, int
         break;
       }else if(left_added != j){
         // This is not the last segment.  We add this knot unchanged.
-
-        for(int k = 0; k < FL_SEGSZ; k++) rs[k] = is[k];
+        int k = 0;
+        for( k = 0; k < FL_SEGSZ; k++) rs[k] = is[k];
 
 		rs += FL_SEGSZ;
         n_rs++;
@@ -220,7 +223,8 @@ void L2L1VitMsgMax(double * inp_segs, in
 				   double * x_opt)
 {
   double * is = inp_segs;
-  for(int j = 0; j < n_inp_segs; j++, is += FL_SEGSZ){
+  int j = 0;
+  for(j = 0; j < n_inp_segs; j++, is += FL_SEGSZ){
 
 	double dy = is[FLV_DY];
 	double x = is[FLV_X];
@@ -266,7 +270,8 @@ int L2L1VitFwd(double lam2, double * o,
 		              FL_RESID_COEF * ((wts) ? -wts[0] : -1.0) );
   }
 
-  for(int i = 1; i < n_o; i++){
+  int i = 0;
+  for(i = 1; i < n_o; i++){
 	  double * bp = back_ptrs + (2*i);
 
 	  double * vm2 = (vit_msg1 == mbuf) ? (mbuf + (vit1_len+3)*FL_SEGSZ) : mbuf;
@@ -340,7 +345,8 @@ SEXP L2L1ExpandFit(SEXP betaPath, SEXP b
 	int n_lam2i = LENGTH(lam2Inds);
 	int * lam2i = INTEGER(lam2Inds);
 
-	for(int i = 0; i < n_lam2i; i++){
+        int i,j,k,k2;
+	for(i = 0; i < n_lam2i; i++){
 		SEXP bp_sxp = VECTOR_ELT(betaPath, lam2i[i]);
 		SEXP bsg_sxp = VECTOR_ELT(betaSegs, lam2i[i]);
 
@@ -352,15 +358,15 @@ SEXP L2L1ExpandFit(SEXP betaPath, SEXP b
 		double cur_b = soft_thresh(bv[0], lm1);
 
 		int n_fill = 1 + sgv[1] - sgv[0];
-		for(int j = 0; j < n_fill; j++, ret_fit++){
+		for(j = 0; j < n_fill; j++, ret_fit++){
 			*ret_fit = cur_b;
 		}
 
-		for(int k = 1, k2 = 2; k < n_seg; k++, k2 += 2){
+		for(k = 1, k2 = 2; k < n_seg; k++, k2 += 2){
 			cur_b = soft_thresh(bv[k], lm1);
 			n_fill = 1 + sgv[k2 + 1] - sgv[k2];
 
-			for(int j = 0; j < n_fill; j++, ret_fit++){
+			for(j = 0; j < n_fill; j++, ret_fit++){
 				*ret_fit = cur_b;
 			}
 		}
@@ -379,7 +385,8 @@ SEXP L2L1GetPrimBds(SEXP betaPath, SEXP
 	int n_lam2i = LENGTH(lam2Inds);
 	int * lam2i = INTEGER(lam2Inds);
 
-	for(int i = 0; i < n_lam2i; i++){
+        int i,j,k,k2;
+	for(i = 0; i < n_lam2i; i++){
 		SEXP bp_sxp = VECTOR_ELT(betaPath, lam2i[i]);
 		SEXP bsg_sxp = VECTOR_ELT(betaSegs, lam2i[i]);
 
@@ -388,7 +395,7 @@ SEXP L2L1GetPrimBds(SEXP betaPath, SEXP
 
 		int * sgv = INTEGER(bsg_sxp);
 
-		for(int j = 0; j < n_lam1; j++){
+		for(j = 0; j < n_lam1; j++){
 
 			double lm1 = lam1v[j];
 			double bd1 = 0.0, bd2 = 0.0;
@@ -397,7 +404,7 @@ SEXP L2L1GetPrimBds(SEXP betaPath, SEXP
 
 			bd1 += fabs(cur_b) * (double)(1 + sgv[1] - sgv[0]);
 
-			for(int k = 1, k2 = 2; k < n_seg; k++, k2 += 2){
+			for(k = 1, k2 = 2; k < n_seg; k++, k2 += 2){
 				double next_b = soft_thresh(bv[k], lm1);
 
 				bd1 += fabs(next_b) * (double)(1 + sgv[k2 + 1] - sgv[k2]);
@@ -420,12 +427,13 @@ int L2L1GetNFused(double beta_hat, int n
 	double btht = beta_hat;
 	int nfsd2 = 0;
 
+        int i,j;
 	if(n_o == 1){
 	  nfsd2 = 1;
 	}else{
 	  double * bp = back_ptrs + (2*(n_o-1));
 
-	  for(int i = n_o-2; i >= 0; i--, bp -= 2){
+	  for(i = n_o-2; i >= 0; i--, bp -= 2){
 
 		  if(btht > bp[1]){
 			  btht = bp[1];
@@ -453,7 +461,8 @@ void L2L1BackTrace(double beta_last, dou
 
   double rbd1 = fabs(prev_b_shr), rbd2 = 0.0;
 
-  for(int i = n_obs-2; i >= 0; i--, bp -= 2){
+  int i;
+  for(i = n_obs-2; i >= 0; i--, bp -= 2){
 
 	  if(prev_b > bp[1]){
 		  cur_b = bp[1];
@@ -501,7 +510,8 @@ SEXP L2L1Vit(SEXP obsSeq, SEXP obsWts, S
   int * n_segs = INTEGER(nSegs);
 
   double obs_min = R_PosInf, obs_max = R_NegInf;
-  for(int i = 0; i < n_obs; i++){
+  int i;
+  for(i = 0; i < n_obs; i++){
 	  if(R_FINITE(o[i])){
 		  if(o[i] < obs_min) obs_min = o[i];
 		  else if(o[i] > obs_max) obs_max = o[i];
@@ -563,9 +573,10 @@ SEXP L2L1VitPath(SEXP obsSeq, SEXP lambd
 
   SEXP ret_sxp;
   PROTECT(ret_sxp = NEW_INTEGER(1)); n_protect++;
+  int i,lam2i,k;
 
   double obs_min = R_PosInf, obs_max = R_NegInf;
-  for(int i = 0; i < n_obs; i++){
+  for(i = 0; i < n_obs; i++){
 
 	  if(R_FINITE(all_obs[i])){
 		  if(all_obs[i] < obs_min) obs_min = all_obs[i];
@@ -583,7 +594,7 @@ SEXP L2L1VitPath(SEXP obsSeq, SEXP lambd
 
   double * prim_bds = (primBds == R_NilValue) ? NULL : REAL(primBds);
 
-  for(int lam2i = 0; lam2i < n_lam2; lam2i++){
+  for(lam2i = 0; lam2i < n_lam2; lam2i++){
 
 	  double lam2 = REAL(lambda2)[lam2i];
 
@@ -643,7 +654,7 @@ SEXP L2L1VitPath(SEXP obsSeq, SEXP lambd
 		  fit_v[(nfsd2-1) - n_fused2] = beta_hat_shr;
 		  bd1 += fabs(beta_hat_shr);
 	  }else{
-		  for(int k = seg_L; k <= seg_R; k++){
+		  for(k = seg_L; k <= seg_R; k++){
 			  fit_v[k] = beta_hat_shr;
 		  }
 		  bd1 += fabs(beta_hat_shr) * (double)(1+seg_R - seg_L);
@@ -667,7 +678,7 @@ SEXP L2L1VitPath(SEXP obsSeq, SEXP lambd
 		  wts2[0] = wts[0];
 	  }
 
-	  for(int i = n_o-2; i >= 0; i--){
+	  for(i = n_o-2; i >= 0; i--){
 		  seg_R = (fs) ? fs[0] : i;
 		  seg_L = (fs) ? fs[1] : i;
 
@@ -712,7 +723,7 @@ SEXP L2L1VitPath(SEXP obsSeq, SEXP lambd
 		  if(segmented_ret){
 			  fit_v[(nfsd2-1) - n_fused2] = beta_hat_shr;
 		  }else{
-			  for(int k = seg_L; k <= seg_R; k++){
+			  for(k = seg_L; k <= seg_R; k++){
 				  fit_v[k] = beta_hat_shr;
 			  }
 		  }
@@ -742,7 +753,7 @@ SEXP L2L1VitPath(SEXP obsSeq, SEXP lambd
 		  wts3 = AllocProtectReal(n_fused2);  n_protect++;
 	  }
 
-	  for(int i = 0; i < n_fused2; i++){
+	  for(i = 0; i < n_fused2; i++){
 		  if( wts2[n_fused2-1-i] > 0.0 ){
 
 			  double z = o2[n_fused2-1-i] / wts2[n_fused2-1-i];
@@ -775,7 +786,7 @@ SEXP L2L1VitPath(SEXP obsSeq, SEXP lambd
 		  UNPROTECT(2);
 
 		  int * seg_v = INTEGER(VECTOR_ELT(segmentVec, lam2i));
-		  for(int k = 0; k < nfsd2; k++){
+		  for(k = 0; k < nfsd2; k++){
 			  seg_v[1+2*k] = fused_segs2[(nfsd2-1-k)*2]+1;
 			  seg_v[2*k] = fused_segs2[1+(nfsd2-1-k)*2]+1;
 		  }
@@ -794,11 +805,11 @@ SEXP L2L1VitPath(SEXP obsSeq, SEXP lambd
   free(msg_buf);
 
   if(segmented_ret){
-	  for(int lam2i = 0; lam2i < n_lam2; lam2i++){
+	  for(lam2i = 0; lam2i < n_lam2; lam2i++){
 		   double * bv = REAL(VECTOR_ELT(retPath, lam2i));
 		   int m = LENGTH(VECTOR_ELT(retPath, lam2i));
 
-		   for(int i = 0; i < m; i++){
+		   for(i = 0; i < m; i++){
 			   bv[i] = soft_thresh(bv[i], lam1);
 		   }
 	  }
@@ -806,7 +817,7 @@ SEXP L2L1VitPath(SEXP obsSeq, SEXP lambd
 	   double * bv = REAL(retPath);
 	   int m = LENGTH(retPath);
 
-	   for(int i = 0; i < m; i++){
+	   for(i = 0; i < m; i++){
 		   bv[i] = soft_thresh(bv[i], lam1);
 	   }
   }
